# 正则表达式 笔记

[参考链接](https://www.cnblogs.com/zery/p/3438845.html)



> 我看不懂的，我就不写上去了

| ^     | 匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。 |
| ----- | ------------------------------------------------------------ |
| $     | 会匹配行或字符串的结尾                                       |
| \d    | 匹配数字                                                     |
| \w    | 匹配字母，数字，下划线.                                      |
| \s    | 匹配空格                                                     |
| **.** | 匹配除了换行符以外的任何字符                                 |
| [abc] | 字符组  匹配包含括号内元素的字符                             |

> 几种反义

写法很简单改成大写就行了，意思与原来的相反

| \W         | 匹配任意不是字母，数字，下划线 的字符 |
| ---------- | ------------------------------------- |
| **\S**     | 匹配任意不是空白符的字符              |
| **\D**     | 匹配任意非数字的字符                  |
| [**^abc**] | 匹配除了abc以外的任意字符             |



> 贪婪,	懒惰,	占有

| *    | 0 --- ∞ |
| ---- | ------- |
| +    | 1 --- ∞ |
| ?    | 0 --- 1 |

| {n}       | 重复n次         |
| --------- | --------------- |
| **{n,m}** | 重复n到m次      |
| **{n,}**  | 重复n次或更多次 |



> **懒惰限定符**

​	　**"\*?"**   重复任意次，但尽可能少重复 

　　    如 "acbacb"  正则  "a.*?b" 只会取到第一个"acb" 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而"acbacb"最少字符的结果就是"acb" 

　　**"+?"**  重复1次或更多次，但尽可能少重复

　　   与上面一样，只是至少要重复1次

　　**"??"**  重复0次或1次，但尽可能少重复

　　    如 "aaacb" 正则 "a.??b" 只会取到最后的三个字符"acb"

　　**"{n,m}?"**  重复n到m次，但尽可能少重复

​          如 "aaaaaaaa"  正则 "a{0,m}" 因为最少是0次所以取到结果为空

　　**"{n,}?"**    重复n次以上，但尽可能少重复

​          如 "aaaaaaa"  正则 "a{1,}" 最少是1次所以取到结果为 "a"





> 捕获分组

　　先了解在正则中捕获分组的概念，其实就是一个括号内的内容 如 "(\d)\d" 而"(\d)"  这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\d)\d\1  这里的"\1"就是对"(\d)"的后向引用

那捕获分组有什么用呢看个例子就知道了

如  "zery zery" 正则 \b(\w+)\b\s\1\b 所以这里的"\1"所捕获到的字符也是 与(\w+)一样的"zery"，为了让组名更有意义，组名是可以自定义名字的

"\b(?<name>\w+)\b\s\k<name>\b" 用"?<name>"就可以自定义组名了而要后向引用组时要记得写成 "\k<name>";自定义组名后,捕获组中匹配到的值就会保存在定义的组名里

下面列出捕获分组常有的用法

 

**"(exp)"**    匹配exp,并捕获文本到自动命名的组里

**"(?<name>exp)"**   匹配exp,并捕获文本到名称为name的组里

**"(?:exp)"**  匹配exp,不捕获匹配的文本，也不给此分组分配组号

以下为零宽断言

**"(?=exp)"**  匹配exp前面的位置

　　如 "How are you doing" 正则"(?<txt>.+(?=ing))" 这里取ing前所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为"How are you do";

**"(?<=exp)"**  匹配exp后面的位置

　　如 "How are you doing" 正则"(?<txt>(?<=How).+)" 这里取"How"之后所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为" are you doing";

**"(?!exp)"**  匹配后面跟的不是exp的位置

　　如 "123abc" 正则 "\d{3}(?!\d)"匹配3位数字后非数字的结果

**"(?<!exp)"**  匹配前面不是exp的位置

　　如 "abc123 " 正则 "(?<![0-9])123" 匹配"123"前面是非数字的结果也可写成"(?!<\d)123"